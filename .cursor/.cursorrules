# MetMuseum Collection Explorer - Cursor Rules

## Project Overview
Next.js 16 (App Router) application using the Metropolitan Museum of Art Collection API with React Query, Zustand, shadcn/UI, and TypeScript.

## Tech Stack Principles

### Next.js 16 (App Router)
- Use Server Components by default; add 'use client' only when necessary
- Leverage React Server Components for data fetching where possible
- Use `loading.tsx` and `error.tsx` for route-level states
- Implement proper metadata for SEO
- Use dynamic routes with proper params typing
- Prefer `router.replace` with `scroll: false` to minimize RSC requests

### TypeScript
- **STRICT MODE**: Enable strict TypeScript settings
- Never use `any`; prefer `unknown` for truly unknown types
- Define explicit return types for all functions
- Create comprehensive type definitions for API responses
- Use discriminated unions for state management
- Leverage `satisfies` operator for type-safe configurations
- Use const assertions where appropriate (`as const`)

### React Query
- Use query keys as constants in `lib/constants/query-keys.ts`
- Implement proper error handling with typed errors
- Use `staleTime` and `gcTime` from `REACT_QUERY_CONFIG` constants
- Leverage prefetching for better UX
- Use `useInfiniteQuery` for pagination with proper `getNextPageParam`
- Create custom hooks that wrap React Query operations in `lib/hooks/`
- Never access query data without null checks
- Use `retry: false` and `gcTime: 0` in test QueryClient configuration

### Zustand
- Keep stores small and focused (single responsibility)
- Store files in `lib/stores/` with `-store.ts` suffix (e.g., `collections-store.ts`)
- Use `persist` middleware for data that needs to survive reloads
- Create typed selectors to avoid unnecessary re-renders
- Separate actions from state in store definition
- Use shallow equality for object selection
- Export store interface and store hook separately

### shadcn/UI
- Components must be in `components/ui/` directory
- Always implement `asChild` prop using `@radix-ui/react-slot` for composition
- Use `Slot` component when `asChild={true}` to avoid invalid HTML nesting
- Follow shadcn/ui patterns: `forwardRef`, `displayName`, `cva` for variants
- Use `cn()` helper for conditional classes
- Export both component and variants (e.g., `Button`, `buttonVariants`)
- Reference `components.json` for configuration
- Use `asChild` pattern: `<Button asChild><Link href="/">Text</Link></Button>`

### Styling & UI
- Use shadcn/UI components as base, customize thoughtfully
- Follow mobile-first responsive design
- Implement proper focus management and keyboard navigation
- Use CSS variables for theming (follow shadcn conventions)
- Avoid inline styles; prefer Tailwind utility classes
- Use `cn()` helper for conditional classes
- Implement smooth transitions and animations (prefer reduced-motion)
- Use constants from `UI_CONFIG` for delays, thresholds, and limits

## Code Architecture

### Folder Structure
```
app/                    # Next.js App Router
├── api/               # API routes
├── artwork/[id]/      # Dynamic routes
├── collections/       # Collections pages
├── layout.tsx
├── page.tsx
├── loading.tsx
├── error.tsx
└── not-found.tsx

components/
├── ui/                # shadcn/UI components
├── features/          # Feature-specific components
└── layouts/           # Layout components

lib/
├── api/               # API layer
├── hooks/             # Custom hooks (use* prefix)
├── stores/            # Zustand stores (*-store.ts)
├── types/             # TypeScript types
├── utils/             # Utility functions
├── constants/         # Constants and query keys
├── validations/       # Zod schemas
└── providers/         # React providers

stories/               # Storybook stories
__tests__/            # Tests
```

### Naming Conventions
- **Components**: PascalCase files and exports (e.g., `ArtworkCard.tsx`, `export function ArtworkCard`)
- **Hooks**: camelCase with 'use' prefix (e.g., `useArtworkSearch.ts`, `export function useArtworkSearch`)
- **Stores**: kebab-case with '-store' suffix (e.g., `collections-store.ts`, `useCollectionsStore`)
- **Utils**: camelCase (e.g., `formatters.ts`, `export function formatDate`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_BASE_URL`, `PAGINATION`)
- **Types/Interfaces**: PascalCase (e.g., `ArtworkObject`, `SearchFilters`)
- **Files**: Match export naming (PascalCase for components, camelCase for hooks/utils)

### API Layer
- Create a centralized API client in `lib/api/client.ts`
- Implement typed responses for all API calls
- Handle errors consistently with typed error responses
- Use environment variables for API endpoints (from `API_CONFIG`)
- Implement retry logic using constants from `API_CONFIG`
- Add request deduplication
- Use constants for timeouts, retry attempts, and rate limits

### Component Design
- Keep components small and focused (< 200 lines)
- Extract business logic into custom hooks in `lib/hooks/`
- Props interfaces should be explicit (no inline types)
- Use composition over prop drilling
- Implement proper loading, error, and empty states
- Follow the "Presentational vs Container" pattern where appropriate
- Feature components in `components/features/`, UI primitives in `components/ui/`

### Code Comments
- **Minimal comments**: Code should be self-documenting through clear naming
- **JSDoc only**: Use JSDoc comments (`/** */`) for exported functions, components, and hooks
- **No inline comments**: Avoid `//` comments explaining obvious code
- **Complex logic only**: Comment only when business logic is non-obvious or requires explanation
- **WHY not WHAT**: If commenting, explain WHY, not WHAT the code does

## Testing Strategy

### Unit Tests
- Test utility functions thoroughly
- Test custom hooks with `@testing-library/react` `renderHook`
- Mock external dependencies (API calls, external libraries)
- Test edge cases and error scenarios
- Aim for high coverage on business logic
- Use descriptive test names following pattern: `should [expected behavior] when [condition]`

### Test Structure
- Use `createWrapper()` from `lib/utils/unit-test` for React Query hooks
- Use `createMockArtwork()` from `lib/utils/unit-test` for mock data
- Use `createTestQueryClient()` for isolated QueryClient instances
- Follow Arrange-Act-Assert pattern
- One assertion per test when possible
- Use data-testid sparingly (prefer accessible queries: `getByRole`, `getByLabelText`)
- Mock API calls consistently at the module level

### Testing Best Practices
- **NO hardcoded timeouts**: Never use `setTimeout`, `setInterval`, or hardcoded delays in tests
- **Use `waitFor`**: Always use `waitFor` from `@testing-library/react` for async assertions
- **No sleep/delay utilities**: Avoid `sleep()`, `delay()`, or similar utilities
- **Proper async handling**: Use `async/await` with `waitFor` for all async test operations
- **Mock timers**: Use Jest fake timers only when testing time-dependent logic
- **Test isolation**: Each test should be independent and not rely on previous test state

### Example Test Pattern
```typescript
it('should fetch and return artworks on success', async () => {
  mockSearchArtworks.mockResolvedValue({ total: 5, objectIDs: [1, 2, 3] })
  
  const { result } = renderHook(
    () => useArtworkSearch({ query: 'test' }),
    { wrapper: createWrapper() }
  )
  
  await waitFor(() => expect(result.current.isSuccess).toBe(true))
  expect(result.current.data).toBeDefined()
})
```

## Library Usage Standards

### shadcn/UI
- Always implement `asChild` prop correctly using `Slot` from `@radix-ui/react-slot`
- Use `components.json` for configuration
- Follow shadcn/ui component patterns exactly
- Never nest interactive elements (use `asChild` instead)

### React Query
- Use query keys from `QUERY_KEYS` constants
- Use config values from `REACT_QUERY_CONFIG` constants
- Create custom hooks that wrap `useQuery`/`useInfiniteQuery`
- Always handle loading, error, and success states

### Zustand
- Use `persist` middleware for client-side persistence
- Keep stores focused on single domain
- Export typed store hooks (e.g., `useCollectionsStore`)

### Zod
- Define schemas in `lib/validations/`
- Use for runtime type validation
- Validate API responses and user inputs

## Security Best Practices

### Input Validation
- Sanitize all user inputs before display using `lib/utils/sanitize`
- Validate form inputs on both client and server with Zod
- Use zod schemas for runtime type validation
- Implement rate limiting for API calls
- Never trust client-side data

### API Security
- Never expose API keys in client code
- Use Next.js API routes as proxy when needed
- Implement proper CORS handling
- Use timeout limits from `API_CONFIG`
- Log security-relevant events

### Content Security
- Sanitize HTML content (especially from API) using sanitize utilities
- Use `next/image` for image optimization and security
- Implement proper CSP headers
- Validate URLs before navigation
- Handle external links safely (noopener, noreferrer)

## Code Quality Standards

### Clean Code Principles
- **DRY**: Don't Repeat Yourself - extract reusable logic to utils/hooks
- **SOLID**: Follow SOLID principles, especially Single Responsibility
- **KISS**: Keep It Simple - avoid over-engineering
- **YAGNI**: You Aren't Gonna Need It - don't add unused features
- Self-documenting code: use clear naming over comments
- Pure functions where possible
- Immutable data patterns

### Function Guidelines
- Prefer arrow functions for components and utilities
- Max 3-4 parameters; use object for more
- Single responsibility per function
- Early returns for guard clauses
- Descriptive names that explain purpose
- Async/await over promise chains
- Explicit return types for all functions

### Code Readability & Control Flow
- **Avoid deeply nested if-else chains**: Prefer early returns, guard clauses, or extracted helper functions
- **Extract complex conditionals**: Move nested logic into separate functions with descriptive names
- **Use helper functions**: Extract repeated patterns (e.g., type conversions, validations) into reusable helpers
- **Prefer flat structure**: Keep nesting levels to maximum 2-3 levels deep
- **Use switch statements**: When checking multiple values of the same variable, prefer switch over if-else chains
- **Strategy pattern**: For complex conditional logic, consider using object maps or strategy functions
- **Example refactoring**: Instead of nested if-else, extract sanitization logic into helper functions and use early returns

### Error Handling
- Use try-catch for async operations
- Create custom error classes when needed
- Provide user-friendly error messages from `ERROR_MESSAGES`
- Log errors for debugging (exclude sensitive data)
- Implement error boundaries
- Handle edge cases explicitly

## Accessibility (A11Y)

### ARIA Implementation
- Use semantic HTML first, ARIA second
- Proper heading hierarchy (h1 → h2 → h3)
- Label all interactive elements
- Implement skip links
- Use role attributes appropriately
- Add aria-live for dynamic content
- Use `aria-label` for icon-only buttons
- Use `aria-hidden="true"` for decorative icons

### Keyboard Navigation
- All interactive elements must be keyboard accessible
- Logical tab order
- Visible focus indicators
- Escape key to close modals/dialogs
- Enter/Space for buttons
- Arrow keys for navigation where appropriate

### Screen Reader Support
- Meaningful alt text for images
- aria-label for icon-only buttons
- Announce loading states
- Describe dynamic content changes
- Use aria-describedby for additional context

## Performance Optimization

### React Optimization
- Use `React.memo()` for expensive components
- Implement proper key props in lists
- Avoid inline function definitions in JSX
- Use `useCallback` and `useMemo` appropriately
- Lazy load components with dynamic imports
- Implement code splitting at route level

### Data Fetching
- Parallel data fetching where possible
- Prefetch on hover for better perceived performance
- Implement optimistic updates for mutations
- Use pagination/infinite scroll for large lists
- Cache responses aggressively with React Query
- Implement request deduplication

### Assets & Images
- Use `next/image` for automatic optimization
- Lazy load images below the fold
- Implement proper image sizing
- Use modern formats (WebP, AVIF)
- Preload critical assets
- Implement skeleton screens

## Constants & Configuration

### Centralized Constants
- All constants in `lib/constants/config.ts`
- Use `as const` for type safety
- Group related constants (API_CONFIG, PAGINATION, UI_CONFIG, etc.)
- Never hardcode values that should be configurable
- Use constants in tests instead of magic numbers

### Environment Variables
- Use `.env.local` for local development
- Never commit `.env` files
- Document all required variables
- Validate environment variables on startup
- Use `NEXT_PUBLIC_` prefix for client-side vars

## Storybook Best Practices

### Story Organization
- One story file per component in `stories/`
- Include all visual states
- Use Controls for interactive props
- Document component usage
- Include accessibility addon
- Show responsive behavior

### Story Types
- Default state
- Loading state
- Error state
- Empty state
- With data/populated
- Edge cases (long text, missing data)
- Interactive states (hover, focus, active)

## Git Practices

### Commits
- Atomic commits (one logical change)
- Descriptive commit messages
- Follow conventional commits format
- Commit working code only
- Don't commit secrets or API keys

### Branches
- Feature branches from main
- Descriptive branch names
- Keep branches short-lived
- Regular rebasing with main

## Code Review Checklist
- [ ] Types are comprehensive and correct
- [ ] Error handling is implemented
- [ ] Loading states are handled
- [ ] Accessibility requirements met
- [ ] Tests are written and passing (no hardcoded timeouts)
- [ ] No console errors or warnings
- [ ] Responsive on mobile and desktop
- [ ] Performance considerations addressed
- [ ] Security best practices followed
- [ ] Code follows project conventions
- [ ] No unnecessary comments (only JSDoc for exports)
- [ ] Constants used instead of magic numbers
- [ ] shadcn/ui components use `asChild` correctly
- [ ] Library dependencies used according to best practices

---

**Remember**: Build for users first, developers second. Prioritize UX, accessibility, and performance. Write self-documenting code with minimal comments. Use constants, avoid hardcoded values, and follow established patterns.
